---
layout: post
title: The Most Important Technique for Writing Bug-Free Code
permalink: /writing-bug-free-code/
---
The biggest source of bugs in code in EECS 281, in my experience, is a lack of clean code. _"Hey, if my code works, it works -- there's no need to get all fussy about how I write it,"_ you might say. It's true that you can get full points on the autograder with all of your code shoved in @main@, but do you ever wonder about how those 'genius' programmers in your class get done so quickly? They write their code once and are done.

This guide is aimed at drilling just one critical idea into your head which I guarantee will make you a better programmer. (More importantly, it will get you full points faster.) Here it is: *never duplicate code*.

h1. Never duplicate code

What's the problem with duplicating code? I have no idea. TODO

h1. Don't repeat expressions

Suppose you calculate a variable and you use it in many places. Don't write out the calculation in each place, but save it to a local variable and use that instead.

TODO: Think of an example.

h1. Don't repeat variables

Sometimes you want to reference the same variable over and over again; in that case, use a temporary reference.

{% highlight cpp %}
// Multidimensional vector.
std::vector<std::vector<std::vector<MyClass>>> myVector;
populateVector(myVector);

for (int i = 0; i < myVector.size(); i++) {
    for (int j = 0; j < myVector[i].size(); j++) {
        for (int k = 0; k < myVector[i][j].size(); k++) {
            someValue += myVector[i][j][k].doSomething();

            myVector[i][j][k].doSomethingElse(someValue);

            if (myVector[i][j][k].someCondition()) {
                myVector[i][j][k].doSomethingConditionally();
            }

            // And so on for many, many lines of code...
        }
    }
}
{% endhighlight %}

You can see that we repeat @myVector[i][j][k]@ many times. If the indices are more complicated, it's really painful to keep typing it out. (In fact, this is one of the already-legible cases; indices can often be much more verbose when using a @map@ later in the course.)

The easiest way to avoid this duplication is to assign the element to a reference:

{% highlight cpp %}
// Multidimensional vector.
std::vector<std::vector<std::vector<MyClass>>> myVector;
populateVector(myVector);

for (int i = 0; i < myVector.size(); i++) {
    for (int j = 0; j < myVector[i].size(); j++) {
        for (int k = 0; k < myVector[i][j].size(); k++) {
            auto& myValue = myVector[i][j][k];

            someValue += myValue.doSomething();

            myValue.doSomethingElse(someValue);

            if (myValue.someCondition()) {
                myValue.doSomethingConditionally();
            }

            // And so on for many, many lines of code...
        }
    }
}
{% endhighlight %}

Lets say you switch to a two-dimensional vector later. It's very easy to modify the second version: just change the @myValue@ definition and your code compiles, while in the first you have to go and change every usage site.

Additionally, if you know that @myValue@ won't be modified, mark it as @const@:

{% highlight cpp %}
// Multidimensional vector.
std::vector<std::vector<std::vector<MyClass>>> myVector;
populateVector(myVector);

for (int i = 0; i < myVector.size(); i++) {
    for (int j = 0; j < myVector[i].size(); j++) {
        for (int k = 0; k < myVector[i][j].size(); k++) {
            const auto& myValue = myVector[i][j][k];

            someValue += myValue.doSomething();

            myValue.doSomethingElse(someValue);

            if (myValue.someCondition()) {
                myValue.doSomethingConditionally();
            }

            // And so on for many, many lines of code...
        }
    }
}
{% endhighlight %}

This can save you quite a bit of headache because it will prevent you from accidentally modifying the element where you didn't mean to.

h1. Handling different modes

A lot of the projects have several different input or output modes. The worst way to handle them is to write the same exact code twice, in two different @if@-branches. Suppose we have a program that reads a list of integers and prints them out in reverse order. Additionally, suppose that in @MODE_EVEN@, we only print the even numbers, and in @MODE_ODD@, we only print the odd ones. Here's a naive approach:

{% highlight cpp %}
int main() {
    std::string mode;
    std::cin >> mode;

    if (mode == "MODE_EVEN") {
        std::vector<int> numbers;
        int number;
        while (std::cin >> number) {
            numbers.push_back(number);
        }

        for (int i = numbers.size() - 1; i >= 0; i--) {
            if (numbers[i] % 2 == 0) {
                std::cout << numbers[i] << std::endl;
            }
        }
    } else {
        std::vector<int> numbers;
        int number;
        while (std::cin >> number) {
            numbers.push_back(number);
        }

        for (int i = numbers.size() - 1; i >= 0; i--) {
            if (numbers[i] % 2 == 1) {
                std::cout << numbers[i] << std::endl;
            }
        }
    }
}
{% endhighlight %}

<aside class="aside-info">

I had a bug when I wrote this code! I started from @numbers.size()@ instead of @numbers.size() - 1@, and I had to change it in two places. If this was a larger program, I might not have remembered to change the other place.

Imagine if I submitted it to the autograder and I failed half the test cases. I might not even think to look for this bug, since I thought I had fixed it. You don't want to spend hours searching for a bug that you thought you had addressed.

</aside>

You can see that we repeat a whole segment of code, and the only difference is one innocuous little @1@ versus @0@. What's the best way to deal with this? The first step is to identify which parts of the code are the exact same and which aren't. For example, the input routine is exactly the same for both. Let's move it out of the @if@-block:

{% highlight cpp %}
int main() {
    std::string mode;
    std::cin >> mode;

    std::vector<int> numbers;
    int number;
    while (std::cin >> number) {
        numbers.push_back(number);
    }

    if (mode == "MODE_EVEN") {
        for (int i = numbers.size() - 1; i >= 0; i--) {
            if (numbers[i] % 2 == 0) {
                std::cout << numbers[i] << std::endl;
            }
        }
    } else {
        for (int i = numbers.size() - 1; i >= 0; i--) {
            if (numbers[i] % 2 == 1) {
                std::cout << numbers[i] << std::endl;
            }
        }
    }
}
{% endhighlight %}

Now half of the repeated code is deduplicated. But the iteration over @numbers@ is still repeated. Let's hoist the @for@-loop out of the @if@-block:

{% highlight cpp %}
int main() {
    std::string mode;
    std::cin >> mode;

    std::vector<int> numbers;
    int number;
    while (std::cin >> number) {
        numbers.push_back(number);
    }

    for (int i = numbers.size() - 1; i >= 0; i--) {
        if (mode == "MODE_EVEN") {
            if (numbers[i] % 2 == 0) {
                std::cout << numbers[i] << std::endl;
            }
        } else {
            if (numbers[i] % 2 == 1) {
                std::cout << numbers[i] << std::endl;
            }
        }
    }
}
{% endhighlight %}

Now we don't have the error-prone @for@-loop repeated, but we still have most of the modulus check and the entire output routine duplicated. Since the only thing which differs is the right-hand side of the equality check, we can put that into a variable:

{% highlight cpp %}
int main() {
    std::string mode;
    std::cin >> mode;

    std::vector<int> numbers;
    int number;
    while (std::cin >> number) {
        numbers.push_back(number);
    }

    for (int i = numbers.size() - 1; i >= 0; i--) {
        int remainder;
        if (mode == "MODE_EVEN") {
            remainder = 0;
        } else {
            remainder = 1;
        }

        if (numbers[i] % 2 == remainder) {
            std::cout << numbers[i] << std::endl;
        }
    }
}
{% endhighlight %}

<aside class="aside-warning">

We can't say this:

{% highlight cpp %}
if (mode == "MODE_EVEN") {
    int remainder = 0;
} else {
    int remainder = 1;
}
{% endhighlight %}

The @remainder@ declaration won't be visible outside the @if@-branch, so we won't be able to use it in the following lines.

</aside>

Much better! Now all of the identical logic is written only once, and we've pulled out the differing part into a single variable.

The only thing left to do is calculate the remainder outside the @for@-loop. It doesn't change between iterations, so it doesn't make sense to recalculate it every time.

{% highlight cpp %}
int main() {
    std::string mode;
    std::cin >> mode;

    std::vector<int> numbers;
    int number;
    while (std::cin >> number) {
        numbers.push_back(number);
    }

    int remainder;
    if (mode == "MODE_EVEN") {
        remainder = 0;
    } else {
        remainder = 1;
    }

    for (int i = numbers.size() - 1; i >= 0; i--) {
        if (numbers[i] % 2 == remainder) {
            std::cout << numbers[i] << std::endl;
        }
    }
}
{% endhighlight %}

When making changes to the code, we can now rest assured that changing the iteration bounds or the printing conditions will correctly update every mode.

<aside class="aside-info">

Iterating over a vector in reverse is bug-prone, since the bounds are unusual. (If you're not careful, it's even possible to throw your program into an infinite loop if you use @unsigned int@s as the loop condition.)

The best way to actually do it would be to use a reverse iterator. Here's one way:

{% highlight cpp %}
for (auto it = numbers.rbegin(); it != numbers.rend(); ++it) {
    if (*it % 2 == remainder) {
        std::cout << *it << std::endl;
    }
}
{% endhighlight %}

</aside>
